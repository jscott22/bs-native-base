// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");

function option_map(fn, opt_value) {
  if (opt_value) {
    return /* Some */[Curry._1(fn, opt_value[0])];
  } else {
    return /* None */0;
  }
}

function optBoolToOptJsBoolean(param) {
  if (param) {
    return /* Some */[param[0]];
  } else {
    return /* None */0;
  }
}

function $less$less(f, g, x) {
  return Curry._1(f, Curry._1(g, x));
}

function dictEntries(dict) {
  var keys = Object.keys(dict);
  var l = keys.length;
  var values = Caml_array.caml_make_vect(l, 0);
  for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
    var key = keys[i];
    Caml_array.caml_array_set(values, i, /* tuple */[
          key,
          dict[key]
        ]);
  }
  return values;
}

function dictValues(dict) {
  var keys = Object.keys(dict);
  var l = keys.length;
  var values = Caml_array.caml_make_vect(l, 0);
  for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
    Caml_array.caml_array_set(values, i, dict[keys[i]]);
  }
  return values;
}

function dictFromList(entries) {
  var dict = { };
  var _param = entries;
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      dict[match[0]] = match[1];
      _param = param[1];
      continue ;
    } else {
      return dict;
    }
  };
}

function dictFromArray(entries) {
  var dict = { };
  var l = entries.length;
  for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
    var match = entries[i];
    dict[match[0]] = match[1];
  }
  return dict;
}

exports.option_map = option_map;
exports.optBoolToOptJsBoolean = optBoolToOptJsBoolean;
exports.$less$less = $less$less;
exports.dictEntries = dictEntries;
exports.dictValues = dictValues;
exports.dictFromList = dictFromList;
exports.dictFromArray = dictFromArray;
/* No side effect */
